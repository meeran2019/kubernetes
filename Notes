
--------------------------------------------------------------------------------------------------------
ARCHITECTURE:
--------------------------------------------------------------------------------------------------------

Nodes   - It is a machine (physical or virtual) where application/container runs.
Cluster - Group of nodes. Support high availability and consists of worker and master nodes. Also helps to sharing load. 
Master Node - It contains control plane and controls/manages worker nodes. If one worker node fails, route the traffic to another worker node. Master nodes can be single or multiple master nodes. 

Components:

api-server  - Act as frontend , users, CLI interact through this. 
etcd        - It is distributed key value pair. Stores all the kubernetes information. For example store cluster information. 
scheduler   - Responsible to run container or distribute load across nodes. 
controller  - It make sure replicas are maintained. 
container runtime   -   It helps to run containers like docker. 
kubelet     -  Agent runs on node. 

Master Vs Worker Nodes: 

Worker Nodes:
    Container Run Time Installed. 
    Kubelet Installed. 
    It has kube proxy. 

Master: 
    It has kube api-server. 
    It has etcd. 
    It has contoller and scheduler. 

Kubectl: It is CLI to interact with kubernetes. 
    kubectl cluster-info    
    kubectl get nodes 

--------------------------------------------------------------------------------------------------------
KUBERNETES OBJECTS:
--------------------------------------------------------------------------------------------------------

PODS: 

    It is kubernetes smallest object and has single instance. It can contain single or multiple container (helper container).

    Generally 1 to 1 relationship between pod and container. Each pod contain single container. 
    Depends upon load to increase the pod with in same or different nodes. 

    READY - Running containers in POD / Total containers in POD. 
    State - Waiting - ImagePullBackOff error - when docker image is not available. 

--------------------------------------------------------------------------------------------------------

YAML FORMAT: 

    apiVersion: api_version
    kind: Pod/Replicaset/Deployment 
    metadata: 
      name:  (Name of kind)
      labels: (Key Value Pair) 
    spec: 
        (Depending upon object, this will change)

--------------------------------------------------------------------------------------------------------

REPLICASETS: 

    It helps to ensure the no of replica (pod) is always running. If node or pod is down, can run in another node. 

    Replication Controller  -> It is older. Existing labels will NOT be considered.No Selector.  
    Replication Set         -> It is new recommended. Existing labels will be considered. Have selector with matchLabels.

    NAME              DESIRED   CURRENT   READY   AGE
    new-replica-set   4         4         0       8s

    Desired - No of replicas. 
    Current - No of pod created. 
    Ready   - No of pod is running. 

--------------------------------------------------------------------------------------------------------

DEPLOYMENTS:     

    It helps to deploy the applications and upgrade using rolling update etc. 
    Underlying uses replicaset. 
    It helps with rollout. 
    Yaml file is same as replicaset i.e) only kind will be changed. 
    Containers -> Pods -> Replicaset -> Deployment. 

--------------------------------------------------------------------------------------------------------

NAMESPACES: 

    It is logical separation which acts separately. Useful to separate by environment etc like dev, test, prod. 
    It consists of: 
        kube-system
        kube-public 
        default 
    Can create new namespace and assign resoures to namespaces. 

    Within namespace, call directly by service name - service_name
    Outside of namespace, call using namespace      - service_name.namespace.svc.cluster.local 

    Namespace object used to create namespace in yaml format. 
    ResourceQuota object used to assign resoure to namespaces in yaml format. 


--------------------------------------------------------------------------------------------------------
CONFIGURATIONS
--------------------------------------------------------------------------------------------------------

COMMANDS AND ENTRYPOINT IN DOCKER: 

    Containers are meant to run specific task and container exists once process completed. 

    CMD sleep 5   or CMD ["sleep","5"]

    docker run ubuntu sleep 10      -> To override the command. 

    Command     -> CLI input is overridden. 
    Entrypoint  -> CLI input is appended. 

    Both entrypoint and command used, so it takes as entrypoint + command 

    ENTRYPOINT ["sleep"]
    CMD ["5"]   -> This will take as sleep 5. 

--------------------------------------------------------------------------------------------------------

COMMANDS AND ARGUMENT IN DOCKER: 

    It act same as docker except change in name. 

    CMD         <-> ARGS  
    ENTRYPOINT  <-> CMD 
    
--------------------------------------------------------------------------------------------------------    
ENVIRONMENT VARIABLES: 

    Can set the environment variable using env property. 
    It is array/list consists of name/value pair for plain text. name/valuefrom pair for configmap or secrets. 

-------------------------------------------------------------------------------------------------------- 

CONFIGMAPS: 

    In environment variable, hard code the value in pod. If any changes in value, require to update all pods. 

    Configmaps helps to store the name and value pair separately and refer in the pod. 

    It consists of: 
        Create the configmap using imperative and declarative way. 
        Inject the configmap to pod. 

    In Pod, it can be referred by using full configmap or specific key value from configmap. 

-------------------------------------------------------------------------------------------------------- 

SECRETS: 

    It is used to store the sensitive data. 

    It consists of: 
        Create the secret 
        Inject the secret to pod. 
    
    It can be create by imperative or declarative way. 

    Data value should be encoded format.

    echo -n 'value' | base64            -> To convert the value to base64 encoded. 

    echo -n 'value' | base64 --decode   -> To decode to plain text. 

    It refer in pod by 3 ways: 
        1. As envFrom   -> To pass the whole secret and secretRef to refer. 
        2. As env       -> To pass the specific key using valueFrom and secretKeyRef. 
        3. As volume    -> To mount the secrets as volume using volumes and secrets. 

-------------------------------------------------------------------------------------------------------- 

SECURITY IN DOCKER: 

    Container and docker engine in host runs in separate namespace. 
    Process ID will be different in different namespace. 
    By default, run as ROOT user. It can override by using --user=1000 or in USER 1000 in Dockerfile.
    ROOT user within container have restriction. 
    /usr/include/linux/capability.h contains the list of capabilities. 
    --cap-add    - to add capability 
    --cap-drop   - to drop capability 
    --privileges - to get all privileges. 

-------------------------------------------------------------------------------------------------------- 

SECURITY CONTEXT: 

    Security Context can be defined at pod or container level or both. 
    Pod level       - It affect that pod and underlying containers. 
    Container level - It affect that container alone. 
    Both level      - Container level overrides the pod level. 

    It is defined using securityContext property. 

    Capabilities support only at container level and not at POD level. 

-------------------------------------------------------------------------------------------------------- 

RESOURCE REQUIREMENTS: 

        CPU, Memory, Disk 
        Resources Request    - It is soft limit. 
        Resources Limit      - It is hard limit. 

        It is applied at each container level. 

        For CPU, it throttles after limit. For memory, can use more memory than limit and can be terminated. 

-------------------------------------------------------------------------------------------------------- 

SERVICE ACCOUNT: 

    Account types: 
        User account    - use by any humans like admin, developer. 
        Service account - use by machine like application (jenkins, prometheus) uses service account. 

    While create service account, it automatically generate the token. External application uses this token. Token is stored as secret object. 

    Token is taken from secret and used by external applications. 
    For native kubernetes application, just mount the token secret volume. 

    automountServiceAccountToken: false   -> To disable the service account token mount. 

    Using RBAC role binding, linked the service account with role. 

-------------------------------------------------------------------------------------------------------- 

TAINTS AND TOLERATIONS: 

    Taint applied on Nodes. 
    Tolerations applied on Pods. 
    If Tolerations, can withstand Taint, then allow to run the pod on specific nodes. 

    It doesnot tell to go the pod to specific nodes. It just restrict nodes from specific pod. 

    kubectl taint node node-name key=value:TaintEffect   -> Taint 
    kubectl taint node node-name key=value:TaintEffect-  -> UnTaint 

    Taint Effects: 
        NoSchedule          - Guarantee not to place and existing wont impact. 
        PreferNoSchedule    - No guarantee. Existing wont impact. 
        NoExecute           - New pods will not be scheduled and existing pods are evicted (killed).

    In POD, add Tolerations property. 

    Master node has taints only for kube system (control plane). 

-------------------------------------------------------------------------------------------------------- 

NODE NAME: 

    It is simplest method to directly select the node name. 
    It is hard coding the node name to schedule the pod. 

-------------------------------------------------------------------------------------------------------- 

NODE SELECTOR: 

    It helps to select the node based on the labels. 
    First requires to label the nodes and use the nodeSelector in pod to select the node. 
    Useful for simple problem just to select based on the labels. 

-------------------------------------------------------------------------------------------------------- 

NODE AFFINITY: 

    It provides advanced capability to place nodes. 
    It consists of affinity and nodeaffinity. 

    required During Scheduling Ignored During Execution. 
    required/ignored/preferred  - it checks whether required or preferred or ignored.         
    Scheduling/execution        - it checks during scheduling or execution. 

--------------------------------------------------------------------------------------------------------
MULTI CONTAINER PODS
--------------------------------------------------------------------------------------------------------

    Multi container pod created and destroyed together. Shares same network and storage. 

    Types of Design Pattern: 
        Ambassador: 
            Used for processing and data conversion. 
        Adaptor: 
            Used for plugin. To connect to database. 
        Sidecar: 
            Used for logging. Install logging agent as sidecar container. 

--------------------------------------------------------------------------------------------------------
OBSERVABILITY
--------------------------------------------------------------------------------------------------------

READINESS PROBE: 

    It helps to make kubernetes to know that pod is ready to serve user traffic. 

    POD Status: 
        Pending             - waiting to schedule the pod to node. 
        Container creating  - pod is scheduled and download the image and run the container. 
        Running             - it is running status. 
    
    POD Condition: 
        Pod Scheduled 
        Initialized 
        Container Ready 
        Ready               - once ready true, then only allow user traffic. 

    It can be done by: 
        HTTP test   - ping the path 
        TCP test    - ping port 
        EXEC test   - custom script. 
    
--------------------------------------------------------------------------------------------------------    






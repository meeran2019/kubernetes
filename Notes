--------------------------------------------------------------------------------------------------------
ARCHITECTURE:
--------------------------------------------------------------------------------------------------------

Nodes   - It is a machine (physical or virtual) where application/container runs.
Cluster - Group of nodes. Support high availability and consists of worker and master nodes. Also helps to sharing load. 
Master Node - It contains control plane and controls/manages worker nodes. If one worker node fails, route the traffic to another worker node. Master nodes can be single or multiple master nodes. 

Components:

api-server  - Act as frontend , users, CLI interact through this. 
etcd        - It is distributed key value pair. Stores all the kubernetes information. For example store cluster information. 
scheduler   - Responsible to run container or distribute load across nodes. 
controller  - It make sure replicas are maintained. 
container runtime   -   It helps to run containers like docker. 
kubelet     -  Agent runs on node. 

Master Vs Worker Nodes: 

Worker Nodes:
    Container Run Time Installed. 
    Kubelet Installed. 
    It has kube proxy. 

Master: 
    It has kube api-server. 
    It has etcd. 
    It has contoller and scheduler. 

Kubectl: It is CLI to interact with kubernetes. 
    kubectl cluster-info    
    kubectl get nodes 

--------------------------------------------------------------------------------------------------------
KUBERNETES OBJECTS:
--------------------------------------------------------------------------------------------------------

PODS: 

    It is kubernetes smallest object and has single instance. It can contain single or multiple container (helper container).

    Generally 1 to 1 relationship between pod and container. Each pod contain single container. 
    Depends upon load to increase the pod with in same or different nodes. 

    READY - Running containers in POD / Total containers in POD. 
    State - Waiting - ImagePullBackOff error - when docker image is not available. 

--------------------------------------------------------------------------------------------------------

YAML FORMAT: 

    apiVersion: api_version
    kind: Pod/Replicaset/Deployment 
    metadata: 
      name:  (Name of kind)
      labels: (Key Value Pair) 
    spec: 
        (Depending upon object, this will change)

--------------------------------------------------------------------------------------------------------

REPLICASETS: 

    It helps to ensure the no of replica (pod) is always running. If node or pod is down, can run in another node. 

    Replication Controller  -> It is older. Existing labels will NOT be considered.No Selector.  
    Replication Set         -> It is new recommended. Existing labels will be considered. Have selector with matchLabels.

    NAME              DESIRED   CURRENT   READY   AGE
    new-replica-set   4         4         0       8s

    Desired - No of replicas. 
    Current - No of pod created. 
    Ready   - No of pod is running. 

--------------------------------------------------------------------------------------------------------

DEPLOYMENTS:     

    It helps to deploy the applications and upgrade using rolling update etc. 
    Underlying uses replicaset. 
    It helps with rollout. 
    Yaml file is same as replicaset i.e) only kind will be changed. 
    Containers -> Pods -> Replicaset -> Deployment. 

--------------------------------------------------------------------------------------------------------

NAMESPACES: 

    It is logical separation which acts separately. Useful to separate by environment etc like dev, test, prod. 
    It consists of: 
        kube-system
        kube-public 
        default 
    Can create new namespace and assign resoures to namespaces. 

    Within namespace, call directly by service name - service_name
    Outside of namespace, call using namespace      - service_name.namespace.svc.cluster.local 

    Namespace object used to create namespace in yaml format. 
    ResourceQuota object used to assign resoure to namespaces in yaml format. 


--------------------------------------------------------------------------------------------------------
CONFIGURATIONS
--------------------------------------------------------------------------------------------------------

COMMANDS AND ENTRYPOINT IN DOCKER: 

    Containers are meant to run specific task and container exists once process completed. 

    CMD sleep 5   or CMD ["sleep","5"]

    docker run ubuntu sleep 10      -> To override the command. 

    Command     -> CLI input is overridden. 
    Entrypoint  -> CLI input is appended. 

    Both entrypoint and command used, so it takes as entrypoint + command 

    ENTRYPOINT ["sleep"]
    CMD ["5"]   -> This will take as sleep 5. 

--------------------------------------------------------------------------------------------------------

COMMANDS AND ARGUMENT IN DOCKER: 

    It act same as docker except change in name. 

    CMD         <-> ARGS  
    ENTRYPOINT  <-> CMD 
    
--------------------------------------------------------------------------------------------------------    
ENVIRONMENT VARIABLES: 

    Can set the environment variable using env property. 
    It is array/list consists of name/value pair for plain text. name/valuefrom pair for configmap or secrets. 

-------------------------------------------------------------------------------------------------------- 

CONFIGMAPS: 

    In environment variable, hard code the value in pod. If any changes in value, require to update all pods. 

    Configmaps helps to store the name and value pair separately and refer in the pod. 

    It consists of: 
        Create the configmap using imperative and declarative way. 
        Inject the configmap to pod. 

    In Pod, it can be referred by using full configmap or specific key value from configmap. 

-------------------------------------------------------------------------------------------------------- 

SECRETS: 

    It is used to store the sensitive data. 

    It consists of: 
        Create the secret 
        Inject the secret to pod. 
    
    It can be create by imperative or declarative way. 

    Data value should be encoded format.

    echo -n 'value' | base64            -> To convert the value to base64 encoded. 

    echo -n 'value' | base64 --decode   -> To decode to plain text. 

    It refer in pod by 3 ways: 
        1. As envFrom   -> To pass the whole secret and secretRef to refer. 
        2. As env       -> To pass the specific key using valueFrom and secretKeyRef. 
        3. As volume    -> To mount the secrets as volume using volumes and secrets. 

-------------------------------------------------------------------------------------------------------- 

SECURITY IN DOCKER: 

    Container and docker engine in host runs in separate namespace. 
    Process ID will be different in different namespace. 
    By default, run as ROOT user. It can override by using --user=1000 or in USER 1000 in Dockerfile.
    ROOT user within container have restriction. 
    /usr/include/linux/capability.h contains the list of capabilities. 
    --cap-add    - to add capability 
    --cap-drop   - to drop capability 
    --privileges - to get all privileges. 

-------------------------------------------------------------------------------------------------------- 

SECURITY CONTEXT: 

    Security Context can be defined at pod or container level or both. 
    Pod level       - It affect that pod and underlying containers. 
    Container level - It affect that container alone. 
    Both level      - Container level overrides the pod level. 

    It is defined using securityContext property. 

    Capabilities support only at container level and not at POD level. 

-------------------------------------------------------------------------------------------------------- 

RESOURCE REQUIREMENTS: 

        CPU, Memory, Disk 
        Resources Request    - It is soft limit. 
        Resources Limit      - It is hard limit. 

        It is applied at each container level. 

        For CPU, it throttles after limit. For memory, can use more memory than limit and can be terminated. 

-------------------------------------------------------------------------------------------------------- 

SERVICE ACCOUNT: 

    Account types: 
        User account    - use by any humans like admin, developer. 
        Service account - use by machine like application (jenkins, prometheus) uses service account. 

    While create service account, it automatically generate the token. External application uses this token. Token is stored as secret object. 

    Token is taken from secret and used by external applications. 
    For native kubernetes application, just mount the token secret volume. 

    automountServiceAccountToken: false   -> To disable the service account token mount. 

    Using RBAC role binding, linked the service account with role. 

-------------------------------------------------------------------------------------------------------- 

TAINTS AND TOLERATIONS: 

    Taint applied on Nodes. 
    Tolerations applied on Pods. 
    If Tolerations, can withstand Taint, then allow to run the pod on specific nodes. 

    It doesnot tell to go the pod to specific nodes. It just restrict nodes from specific pod. 

    kubectl taint node node-name key=value:TaintEffect   -> Taint 
    kubectl taint node node-name key=value:TaintEffect-  -> UnTaint 

    Taint Effects: 
        NoSchedule          - Guarantee not to place and existing wont impact. 
        PreferNoSchedule    - No guarantee. Existing wont impact. 
        NoExecute           - New pods will not be scheduled and existing pods are evicted (killed).

    In POD, add Tolerations property. 

    Master node has taints only for kube system (control plane). 

-------------------------------------------------------------------------------------------------------- 

NODE NAME: 

    It is simplest method to directly select the node name. 
    It is hard coding the node name to schedule the pod. 

-------------------------------------------------------------------------------------------------------- 

NODE SELECTOR: 

    It helps to select the node based on the labels. 
    First requires to label the nodes and use the nodeSelector in pod to select the node. 
    Useful for simple problem just to select based on the labels. 

-------------------------------------------------------------------------------------------------------- 

NODE AFFINITY: 

    It provides advanced capability to place nodes. 
    It consists of affinity and nodeaffinity. 

    required During Scheduling Ignored During Execution. 
    required/ignored/preferred  - it checks whether required or preferred or ignored.         
    Scheduling/execution        - it checks during scheduling or execution. 

--------------------------------------------------------------------------------------------------------
MULTI CONTAINER PODS
--------------------------------------------------------------------------------------------------------

    Multi container pod created and destroyed together. Shares same network and storage. 

    Types of Design Pattern: 
        Ambassador: 
            Used for processing and data conversion. 
        Adaptor: 
            Used for plugin. To connect to database. 
        Sidecar: 
            Used for logging. Install logging agent as sidecar container. 

--------------------------------------------------------------------------------------------------------
OBSERVABILITY
--------------------------------------------------------------------------------------------------------

READINESS PROBE: 

    It helps to make kubernetes to know that pod is ready to serve user traffic. 

    POD Status: 
        Pending             - waiting to schedule the pod to node. 
        Container creating  - pod is scheduled and download the image and run the container. 
        Running             - it is running status. 
    
    POD Condition: 
        Pod Scheduled 
        Initialized 
        Container Ready 
        Ready               - once ready true, then only allow user traffic. 

    It can be done by: 
        HTTP test   - ping the path 
        TCP test    - ping port 
        EXEC test   - custom script. 
    
--------------------------------------------------------------------------------------------------------    

LIVENESS PROBE: 

    It is health check which periodically checks whether application is healthy. 

    It consists of: 
        HTTP test       - checks the http path. 
        TCP test        - checks the tcp port.
        EXEC command    - checks the command. 
    
    Liveness probe is health check.
    Readiness probe is to check whether container is ready to serve traffic. 

--------------------------------------------------------------------------------------------------------    

LOGGING: 

        docker logs container-id    -> To check logs in docker. 
        kubectl logs -f pod-name    -> To get the logs of pod. 
        kubectl logs -f pod-name container-name     -> To get the logs of container. 

--------------------------------------------------------------------------------------------------------

MONITORING: 

    It helps to know the cpu and memory usage of pod and nodes. Metrics server is used to get the real time metrics. 
    under the hood, uses cAdvisor to ge the metrics details which pass thorugh kubelet. 

    kubectl top node 
    kubectl top pod 

--------------------------------------------------------------------------------------------------------
POD DESIGN: 
--------------------------------------------------------------------------------------------------------

LABELS, SELECTORS & ANNOTATIONS: 

    Labels helps to group things (ex: environment by dev, test or prod)
    Selectors helps to select based on the labels. 

    Annotation is used to record any information that will be useful. 

--------------------------------------------------------------------------------------------------------    
ROLLING UPDATES & ROLLBACKS: 

    Deployment Strategy: 
        Rolling Update   - Install in few pods and no downtime. This is default strategy. 
        Recreate         - Have downtime and old versions are removed completely first and then install new version. 

    Based on Rolling update strategy - 25% max can be down and 25% max extra can take. 

        Selector:               app=nginx
        Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable
        StrategyType:           RollingUpdate
        MinReadySeconds:        0
        RollingUpdateStrategy:  25% max unavailable, 25% max surge
        Pod Template:
        
-------------------------------------------------------------------------------------------------------- 

JOBS: 

    It helps to run the specific set of pod. 
    Job creates one or more pod and retry execution until specified number of them completed successfully.
    When specified number is reached, job is completed. 
    Note: RestartPolicy is Never. 

-------------------------------------------------------------------------------------------------------- 

CRON JOBS: 

    Job can be scheduled using CRON expression. 

    kubectl get cronjob             -> To get the cron job. 

    NAME    SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGE
    hello   30 21 * * *   False     0        <none>          17s

--------------------------------------------------------------------------------------------------------
SERVICES AND NETWORKING: 
--------------------------------------------------------------------------------------------------------

SERVICES: 

    It enables communication within and outside applications/pods. 
    Enables front end application available to end user. 
    Backend application available to frontend application. 
    
    Based on selector, can support multiple pods and load balancing taken care by kubernetes. 
    If no of nodes increased, it will apply to all nodes. 

    Selector is used to link pod to service. 

    It consists of: 
        ClusterIP   - For internal communication (Ex: App to connect to database). 
                Request forwarded to service and service load balances the pod. 
                If pod is down, it doesnot affect as service group pod based on selector. 
                This is default service. 

        NodePort    - For external communication (Ex: User to connect to App).
                Target port (pod), Port (service), Node port (30000-32767 port range).
                Port is mandatory. Default takes target port as port. For node port, takes default in the range of 30000 to 32767. 

        LoadBalancer - It supports in cloud.

--------------------------------------------------------------------------------------------------------

NETWORK POLICIES: 

    













